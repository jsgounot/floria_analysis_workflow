REFERENCES = {
    group: sorted(expand('references/used/{group}/sample/{sample}.fasta', group=group, sample=sorted(samples)))
    for group, samples in config.items()
}

REFERENCES_DICT = {
    group: {sample : f'references/used/{group}/sample/{sample}.fasta' for sample in samples}
    for group, samples in config.items()
}


rule mummer_nucmer:
    input:
        query = 'temp/assemblies/{group}/{basename}.fa',
        ref = lambda wc: REFERENCES[wc.group][int(wc.idx)]
    output:
        'stats/assemblies/{group}/{basename}/mummer/{idx}.delta'
    params:
        prefix = 'stats/assemblies/{group}/{basename}/mummer/{idx}'
    threads:
        4
    conda:
        config['softparams']['conda']['mummer']
    shell:
        'nucmer --maxmatch -t {threads} -p {params.prefix} {input.ref} {input.query}'

rule mummer_delta_filter:
    input:
        rules.mummer_nucmer.output
    output:
        'stats/assemblies/{group}/{basename}/mummer/{idx}.qdelta'
    conda:
        config['softparams']['conda']['mummer']
    shell:
        'delta-filter -q {input} > {output}'

rule mummer_show_coords:
    input:
        rules.mummer_delta_filter.output
    output:
        'stats/assemblies/{group}/{basename}/mummer/{idx}.qcoords'
    conda:
        config['softparams']['conda']['mummer']
    shell:
        'show-coords -qHTlc {input} > {output}'

def get_qcoords(wildcards):
    count = len(REFERENCES[wildcards.group])
    group = [wildcards.group for _ in range(count)]
    basename = [wildcards.basename for _ in range(count)]
    idx = list(range(count))

    return expand( 
        'stats/assemblies/{group}/{basename}/mummer/{idx}.qcoords',
        zip, group=group, basename=basename, idx=idx
        )

rule extract_best_results:
    input:
        get_qcoords
    output:
        'stats/assemblies/{group}/{basename}/mummer/best_results.tsv'
    conda:
        config['softparams']['conda']['mummer']
    script:
        'scripts/assemblies_stats_analyse_nucmer.py'

checkpoint make_best_subfa:
    input:
        table = rules.extract_best_results.output,
        query = 'temp/assemblies/{group}/{basename}.fa'
    params:
        idx = lambda wc: wc.idx
    output:
        'stats/assemblies/{group}/{basename}/mummer/{idx}.best.fa'
    script:
        'scripts/assemblies_stats_extract.py'

rule mummer_nucmer_best:
    input:
        query = rules.make_best_subfa.output,
        ref = lambda wc: REFERENCES[wc.group][int(wc.idx)]
    output:
        'stats/assemblies/{group}/{basename}/mummer/{idx}.best.full.delta'
    params:
        prefix = 'stats/assemblies/{group}/{basename}/mummer/{idx}.best.full'
    threads:
        4
    conda:
        config['softparams']['conda']['mummer']
    shell:
        'nucmer --maxmatch -t {threads} -p {params.prefix} {input.ref} {input.query}'

rule mummer_dnadiff_best_complete:
    input:
        rules.mummer_nucmer_best.output
    output:
        'stats/assemblies/{group}/{basename}/mummer/{idx}.best.full.report'
    params:
        prefix = 'stats/assemblies/{group}/{basename}/mummer/{idx}.best.full'
    conda:
        config['softparams']['conda']['mummer']
    shell:
        'dnadiff -p {params.prefix} -d {input}'

rule mummer_dnadiff_best_empty:
    output:
        touch('stats/assemblies/{group}/{basename}/mummer/{idx}.best.empty.report')

def get_report(wildcards):
    output = checkpoints.make_best_subfa.get(** wildcards).output[0]
    if os.stat(output).st_size == 0:
        return rules.mummer_dnadiff_best_empty.output
    else:
        return rules.mummer_dnadiff_best_complete.output

rule mummer_dnadiff_best:
    input:
        get_report
    output:
        'stats/assemblies/{group}/{basename}/mummer/{idx}.best.report'
    shell:
        'ln -s $(pwd)/{input} {output}'

def get_reports(wildcards):
    count = len(REFERENCES[wildcards.group])
    group = [wildcards.group for _ in range(count)]
    basename = [wildcards.basename for _ in range(count)]
    idx = list(range(count))

    return expand( 
        'stats/assemblies/{group}/{basename}/mummer/{idx}.best.report',
        zip, group=group, basename=basename, idx=idx
        )

rule parse_report:
    input:
        get_reports
    output:
        'stats/assemblies/{group}/{basename}/mummer/report.tsv'
    params:
        lambda wc: REFERENCES[wc.group]
    script:
        'scripts/assemblies_stats_parse_reports.py'

rule compress_mummer:
    input:
        rules.parse_report.output
    output:
        'stats/assemblies/{group}/{basename}/mummer/mummer_files.tar.gz'
    params:
        path = 'stats/assemblies/{group}/{basename}/mummer/[0-9].*'
    shell:
        'tar -czvf {output} {params.path} --remove-files'

rule prepare_circos_coords:
    input:
        get_reports
    output:
        'stats/assemblies/{group}/{basename}/mummer/circos/1coords.tsv'
    params:
        'stats/assemblies/{group}/{basename}/mummer/*.best.full.1coords'
    shell:
        'awk \'BEGIN{{OFS="\\t"}} $2!="." && $3!="."{{ print $12,$1,$2,$7 }}\' {params} > {output}'

rule prepare_circos_snps:
    input:
        get_reports
    output:
        'stats/assemblies/{group}/{basename}/mummer/circos/snps.int.tsv'
    params:
        'stats/assemblies/{group}/{basename}/mummer/*.best.full.snps'
    shell:
        'for f in {params}; \
        do \
        cat "${{f}}" | sort -k11,11 -k1,1n | \
        awk \'BEGIN{{beg=1}} $2!="." && $3!="."{{ step=int($7/1500)+1;end=beg+step;while($1>end){{beg=end+1;end=beg+step}} snps[beg]+=1;x[beg]=end}} END{{ for(beg in snps){{printf("%s\\t%d\\t%d\\t%d\\n",$11,beg,x[beg],snps[beg])}} }} \'; \
        done | sort -k1,1 -k2,2n > {output}'

rule prepare_circos_karyotype:
    input:
        lambda wc: REFERENCES[wc.group]
    output:
        'stats/assemblies/{group}/{basename}/mummer/circos/karyotype.txt'
    params:
        lambda wc: REFERENCES_DICT[wc.group]
    script:
        'scripts/assemblies_stats_circos_karyotype.py'

rule make_all_files:
    input:
        ancient(rules.parse_report.output),
        ancient(rules.prepare_circos_coords.output),
        ancient(rules.prepare_circos_snps.output),
        ancient(rules.prepare_circos_karyotype.output),
        ancient(rules.compress_mummer.output)
    output:
        touch('stats/assemblies/{group}/{basename}/mummer/circos/done.empty')