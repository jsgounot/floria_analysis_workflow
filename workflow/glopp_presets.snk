import glob, os, json

wildcard_constraints:
    vcaller="longshot|lofreq",
    rtype="long_reads|short_reads"

rule link_vcf:
    input:
        'vcalling/{group}/{refori}.{readtype}.{vcaller}.vcf'
    output:
        'phasing/glopp/{group}/{refori}.{readtype}.{vcaller}.vcf'
    shell:
        'ln -s $(pwd)/{input} {output}'

rule add_header:
    input:
        rules.link_vcf.output
    output:
        'phasing/glopp/{group}/{refori}.{readtype}.{vcaller}.vcfc_header'
    script:
        'scripts/glopp_vcf_header.py'

# Might be useless afterall, keep for archive
rule filter_bam:
    input:
        'mapping/{group}/{refori}.{readtype}.bam'
    output:
        temp('phasing/glopp/tmp_bamfile/{group}.{refori}.{readtype}.filtered.bam')
    conda:
        config['softparams']['conda']['minimap2']
    shell:
        "samtools view -h {input} | awk '!seen[$1]++ || /^@/' | samtools view -b -h > {output}"

rule index_bam:
    input:
        'phasing/glopp/tmp_bamfile/{group}.{refori}.{readtype}.filtered.bam'
    output:
        temp('phasing/glopp/tmp_bamfile/{group}.{refori}.{readtype}.filtered.bam.bai')
    conda:
        config['softparams']['conda']['minimap2']
    shell:
        'samtools index {input}'

# --------------------------------------------------------------------------------------------------

def make_glopp_options(wc):
    fname = '../../configs/glopp_config.json'
    with open(fname) as f:
        d = json.load(f)
    return ' '.join(d[wc.preset])

rule glopp_illumina:
    input:
        fasta = 'references/used/{group}/refmap/{refori}.fa',
        fai   = 'references/used/{group}/refmap/{refori}.fa.fai',
        bam   = 'mapping/{group}/{refori}.illumina.bam',
        bai   = 'mapping/{group}/{refori}.illumina.bam.bai',
        vcf   = 'phasing/glopp/{group}/{refori}.illumina.{vcaller}.vcfc_header',
        exe   = config['softparams']['soft']['glopp']
    output:
        outdir = directory('phasing/glopp/{group}/{refori}/illumina_{preset}/{vcaller}')
    benchmark:
        'benchmarks/{group}/glopp.{refori}.illumina_{preset}.{vcaller}.txt'
    conda:
        config['softparams']['conda']['glopp']
    params:
        preset_opts = make_glopp_options
    threads:
        16
    log:
        'logs/{group}/glopp.{refori}.illumina_{preset}.{vcaller}.log'
    shell:
        '{input.exe} -b {input.bam} -c {input.vcf} -o {output.outdir} -t {threads} -R {input.fasta} {params.preset_opts} > {log}'

rule glopp_nanopore:
    input:
        fasta = 'references/used/{group}/refmap/{refori}.fa',
        fai   = 'references/used/{group}/refmap/{refori}.fa.fai',
        bam   = 'mapping/{group}/{refori}.nanopore.bam',
        bai   = 'mapping/{group}/{refori}.nanopore.bam.bai',
        vcf   = 'phasing/glopp/{group}/{refori}.nanopore.{vcaller}.vcfc_header',
        exe   = config['softparams']['soft']['glopp']
    output:
        outdir = directory('phasing/glopp/{group}/{refori}/nanopore_{preset}/{vcaller}')
    benchmark:
        'benchmarks/{group}/glopp.{refori}.nanopore_{preset}.{vcaller}.txt'
    conda:
        config['softparams']['conda']['glopp']
    params:
        preset_opts = make_glopp_options
    threads:
        16
    log:
        'logs/{group}/glopp.{refori}.nanopore_{preset}.{vcaller}.log'
    shell:
        '{input.exe} -b {input.bam} -c {input.vcf} -o {output.outdir} -t {threads} -R {input.fasta} {params.preset_opts} > {log}' 

rule glopp_hybrid:
    input:
        fasta = 'references/used/{group}/refmap/{refori}.fa',
        fai   = 'references/used/{group}/refmap/{refori}.fa.fai',
        bam   = 'mapping/{group}/{refori}.nanopore.bam',
        bai   = 'mapping/{group}/{refori}.nanopore.bam.bai',
        short = 'mapping/{group}/{refori}.illumina.bam',
        vcf   = 'phasing/glopp/{group}/{refori}.illumina.{vcaller}.vcfc_header',
        exe   = config['softparams']['soft']['glopp']
    output:
        outdir = directory('phasing/glopp/{group}/{refori}/hybrid_{preset}/{vcaller}')
    benchmark:
        'benchmarks/{group}/glopp.{refori}.hybrid_{preset}.{vcaller}.txt'
    conda:
        config['softparams']['conda']['glopp']
    params:
        preset_opts = make_glopp_options
    threads:
        16
    log:
        'logs/{group}/glopp.{refori}.hybrid_{preset}.{vcaller}.log'
    shell:
        '{input.exe} -b {input.bam} -c {input.vcf} -o {output.outdir} -t {threads} -R {input.fasta} -H {input.short} --reassign-short {params.preset_opts} > {log}'

rule glopp_pacbio:
    input:
        fasta = 'references/used/{group}/refmap/{refori}.fa',
        fai   = 'references/used/{group}/refmap/{refori}.fa.fai',
        bam   = 'mapping/{group}/{refori}.pacbio_{model}.bam',
        bai   = 'mapping/{group}/{refori}.pacbio_{model}.bam.bai',
        vcf   = 'phasing/glopp/{group}/{refori}.pacbio_{model}.{vcaller}.vcfc_header',
        exe   = config['softparams']['soft']['glopp']
    output:
        outdir = directory('phasing/glopp/{group}/{refori}/pacbio_{model}_{preset}/{vcaller}')
    benchmark:
        'benchmarks/{group}/glopp.{refori}.pacbio_{model}_{preset}.{vcaller}.txt'
    conda:
        config['softparams']['conda']['glopp']
    params:
        preset_opts = make_glopp_options
    threads:
        16
    log:
        'logs/{group}/glopp/{refori}.pacbio_{model}_{preset}.{vcaller}.log'
    shell:
        '{input.exe} -b {input.bam} -c {input.vcf} -o {output.outdir} -t {threads} -R {input.fasta} {params.preset_opts} > {log}'

# ------------------------------------------------------------------------------------------------------------------------------------------
# This part is made to compress all directory for both space and files number reduction

rule glopp_done:
    input:
        'phasing/glopp/{group}/{refori}/{gmode}/{vcaller}'
    output: 
        temp(touch('phasing/glopp/{group}/{refori}/{gmode}/{vcaller}.done'))

rule compress_glopp_subdir:
    input:
        rules.glopp_done.output
    output:
        temp('phasing/glopp/{group}/{refori}/{gmode}/{vcaller}/glopp.{dirname}.tar.gz')
    params:
        path = 'phasing/glopp/{group}/{refori}/{gmode}/{vcaller}/*/{dirname}'
    shell:
        'tar -czvf {output} {params.path} --remove-files'

rule prep_glopp_outputs:
    input:
        'phasing/glopp/{group}/{refori}/{gmode}/{vcaller}/glopp.haplotypes.tar.gz',
        'phasing/glopp/{group}/{refori}/{gmode}/{vcaller}/glopp.local_parts.tar.gz',
        'phasing/glopp/{group}/{refori}/{gmode}/{vcaller}/glopp.long_reads.tar.gz',
        'phasing/glopp/{group}/{refori}/{gmode}/{vcaller}/glopp.short_reads.tar.gz',
    output:
        touch('phasing/glopp/{group}/{refori}/{gmode}/{vcaller}/prep.done')
    priority:
        1

checkpoint extract_glopp_reads:
    input:
        tar = 'phasing/glopp/{group}/{refori}/{gmode}/{vcaller}/glopp.{rtype}.tar.gz',
        pre = 'phasing/glopp/{group}/{refori}/{gmode}/{vcaller}/prep.done'
    output:
        temp('phasing/glopp/{group}/{refori}/{gmode}/{vcaller}/glopp.{rtype}.done.tmp')
    shell:
        'tar -xf {input.tar} && touch {output}'

# ------------------------------------------------------------------------------------------------------------------------------------------
# Assembly

WTDBG2PRESETS = {
    'hifi': '-x ccs -R',
    'nanopore': '-x preset2 -e 5 -l 1000 -L 3000 -S 1 -R'
}

GMODES = {
    'illumina':     'illumina',
    'nanopore':     'nanopore',
    'hybrid':       'nanopore',
    'pacbio_bbmap': 'hifi'
}

def get_preset(gmode):
    for key, value in GMODES.items():
        if gmode.startswith(key):
            return value

    raise Exception(f'Unable to define preset for {gmode}')

def get_input_basename(wc):
    checkpoints.extract_glopp_reads.get(** wc).output[0]

    fnames = f'phasing/glopp/{wc.group}/{wc.refori}/{wc.gmode}/{wc.vcaller}/*/{wc.rtype}/*.fastq'
    fnames = glob.glob(fnames)

    if wc.rtype == 'short_reads':
        fnames = list({fname.strip()[:-14] for fname in fnames})

    if wc.rtype == 'long_reads':
        fnames = [fname.strip()[:-6] for fname in fnames]


    # Important here, we define the preset based on the used glopp mode
    assembler = wc.assembler
    preset = get_preset(wc.gmode)

    for idx, fname in enumerate(fnames):
        partID = os.path.basename(fname)
        fnames[idx] = os.path.join(os.path.dirname(fname), f'{assembler}.{partID}.{preset}')

    return fnames

def aggregate_output_fasta(wildcards):
    f = get_input_basename(wildcards)
    return [basename + '.fa' for basename in f]

def aggregate_output_targz(wildcards):
    f = get_input_basename(wildcards)
    return [basename + '.tar.gz' for basename in f]

# I end up using a script here to manage all the possibilites and limit the number of rules / checkpoints

rule wtdbg2:
    input:
        fastq = 'phasing/glopp/{group}/{refori}/{gmode}/{vcaller}/{contigID}/long_reads/{partID}.fastq'
    output:
        fa = temp('phasing/glopp/{group}/{refori}/{gmode}/{vcaller}/{contigID}/long_reads/wtdbg2.{partID}.{wpreset}.fa'),
        ar = temp('phasing/glopp/{group}/{refori}/{gmode}/{vcaller}/{contigID}/long_reads/wtdbg2.{partID}.{wpreset}.tar.gz')
    params:
        wdir = 'phasing/glopp/{group}/{refori}/{gmode}/{vcaller}/{contigID}/long_reads/wtdbg2_{partID}_{wpreset}',
        subname = lambda wc: wc.partID,
        preset = lambda wc: WTDBG2PRESETS[wc.wpreset],
        rmfq = 'True'
    conda:
        config['softparams']['conda']['wtdbg2']
    log:
        'logs/{group}/glopp_wtdbg2/wtdbg2.{group}.{refori}.{gmode}.{vcaller}.{contigID}.long_reads.{partID}.{wpreset}.log'
    benchmark:
        'benchmarks/{group}/glopp_wtdbg2/wtdbg2.{refori}.{gmode}.{vcaller}.{contigID}.long_reads.{partID}.{wpreset}.txt'
    threads:
        16
    script:
        'scripts/run_wtdbg2.py'

# Note regarding unicyler
# I decided to not use it because unicycler uses Spades under the hood
# which is perfectly fine with regular good coverage genomes
# but crashes when coverage is low which happens quite a lot when
# dealing with this kind of cases (or short-binning as well for example)
# I'm using abysspe instead but maybe something better could be use

rule unicycler:
    input:
        r1 = 'phasing/glopp/{group}/{refori}/{gmode}/{vcaller}/{contigID}/short_reads/{partID}_paired1.fastq',
        r2 = 'phasing/glopp/{group}/{refori}/{gmode}/{vcaller}/{contigID}/short_reads/{partID}_paired2.fastq'
    output:
        fa = temp('phasing/glopp/{group}/{refori}/{gmode}/{vcaller}/{contigID}/short_reads/unicycler.{partID}.{wpreset}.fa'),
        ar = temp('phasing/glopp/{group}/{refori}/{gmode}/{vcaller}/{contigID}/short_reads/unicycler.{partID}.{wpreset}.tar.gz')
    params:
        wdir = 'phasing/glopp/{group}/{refori}/{gmode}/{vcaller}/{contigID}/short_reads/unicycler_{partID}_{wpreset}',
        rmfq = 'True'
    conda:
        config['softparams']['conda']['unicycler']
    log:
        'logs/{group}/glopp_unicycler/unicycler.{group}.{refori}.{gmode}.{vcaller}.{contigID}.short_reads.{partID}.{wpreset}.log'
    benchmark:
        'benchmarks/{group}/glopp_unicycler/unicycler.{refori}.{gmode}.{vcaller}.{contigID}.short_reads.{partID}.{wpreset}.txt'
    threads:
        16
    script:
        'scripts/run_unicycler.py'

rule abysspe:
    input:
        r1 = 'phasing/glopp/{group}/{refori}/{gmode}/{vcaller}/{contigID}/short_reads/{partID}_paired1.fastq',
        r2 = 'phasing/glopp/{group}/{refori}/{gmode}/{vcaller}/{contigID}/short_reads/{partID}_paired2.fastq'
    output:
        fa = temp('phasing/glopp/{group}/{refori}/{gmode}/{vcaller}/{contigID}/short_reads/abysspe.{partID}.{wpreset}.fa'),
        ar = temp('phasing/glopp/{group}/{refori}/{gmode}/{vcaller}/{contigID}/short_reads/abysspe.{partID}.{wpreset}.tar.gz')
    params:
        wdir = 'phasing/glopp/{group}/{refori}/{gmode}/{vcaller}/{contigID}/short_reads/abysspe_{partID}_{wpreset}',
        rmfq = 'True'
    conda:
        config['softparams']['conda']['abyss']
    log:
        'logs/{group}/glopp_abysspe/abysspe.{group}.{refori}.{gmode}.{vcaller}.{contigID}.short_reads.{partID}.{wpreset}.log'
    benchmark:
        'benchmarks/{group}/glopp_abysspe/abysspe.{refori}.{gmode}.{vcaller}.{contigID}.short_reads.{partID}.{wpreset}.txt'
    threads:
        2
    script:
        'scripts/run_abysspe.py'

# ------------------------------------------------------------------------------------------------------------------------------------------

rule merge_fasta:
    input:
        aggregate_output_fasta
    output:
        'phasing/assemblies/{group}/{refori}.glopp.{gmode}.{assembler}.{rtype}.{vcaller}.fa'
    script:
        'scripts/glopp_wtdbg2_merger.py'

rule concat_intermediate:
    input:
        aggregate_output_targz
    output: 
        'phasing/glopp/{group}/{refori}/{gmode}/{vcaller}/{rtype}.{assembler}.tar.gz'
    shell:
        'cat {input} > {output}'

rule compress_fasta:
    # Here we make sure we also compressed and remove all the small but numerous files
    # for clusters with file numbers limits (same as strainberry)
    input:
        ic = ancient(rules.concat_intermediate.output),
        fa = ancient(rules.merge_fasta.output)
    output:
        'phasing/assemblies/{group}/{refori}.glopp.{gmode}.{assembler}.{rtype}.{vcaller}.fa.gz'
    shell:
        'gzip {input.fa}'

rule uncompress:
    input:
        rules.compress_fasta.output
    output: 
        temp('temp/assemblies/{group}/{refori}.glopp.{gmode}.{assembler}.{rtype}.{vcaller}.fa')
    shell:
        'zcat {input} > {output}'
