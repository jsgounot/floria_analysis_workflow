import glob, os
from scripts.utilities import get_mapping_ref

GLOPP = '~/glopp/glopp/target/release/glopp'

rule link_vcf:
    input:
        'vcalling/{group}/{refori}.{readtype}.{vcaller}.vcf'
    output:
        'phasing/glopp/{group}/{refori}.{readtype}.{vcaller}.vcf'
    shell:
        'ln -s $(pwd)/{input} {output}'

rule add_header:
    input:
        'phasing/glopp/{group}/{refori}.{readtype}.{vcaller}.vcf'
    output:
        'phasing/glopp/{group}/{refori}.{readtype}.{vcaller}.vcfc_header'
    script:
        'scripts/glopp_vcf_header.py'

rule glopp_illumina:
    input:
        fasta = 'references/used/{group}/refmap/{refori}.fa',
        fai   = 'references/used/{group}/refmap/{refori}.fa.fai',
        bam   = 'mapping/{group}/{refori}.illumina.bam',
        bai   = 'mapping/{group}/{refori}.illumina.bam.bai',
        vcf   = 'phasing/glopp/{group}/{refori}.illumina.{vcaller}.vcfc_header'
    output:
        outdir = directory('phasing/glopp/{group}/{refori}/illumina/{vcaller}')
    benchmark:
        'benchmarks/{group}.glopp.{refori}.illumina.{vcaller}.txt'
    conda:
        config['softparams']['conda']['glopp']
    threads:
        16
    log:
        'logs/{group}/glopp.{refori}.illumina.{vcaller}.log'
    params:
        executable = GLOPP
    shell:
        '{params.executable} -b {input.bam} -c {input.vcf} -o {output.outdir} -t {threads} -R {input.fasta} -e 0.01 > {log}'

rule glopp_nanopore:
    input:
        fasta = 'references/used/{group}/refmap/{refori}.fa',
        fai   = 'references/used/{group}/refmap/{refori}.fa.fai',
        bam   = 'mapping/{group}/{refori}.nanopore.bam',
        bai   = 'mapping/{group}/{refori}.nanopore.bam.bai',
        vcf   = 'phasing/glopp/{group}/{refori}.nanopore.{vcaller}.vcfc_header'
    output:
        outdir = directory('phasing/glopp/{group}/{refori}/nanopore/{vcaller}')
    benchmark:
        'benchmarks/{group}.glopp.{refori}.nanopore.{vcaller}.txt'
    conda:
        config['softparams']['conda']['glopp']
    threads:
        16
    log:
        'logs/{group}/glopp.{refori}.nanopore.{vcaller}.log'
    params:
        executable = GLOPP
    shell:
        '{params.executable} -b {input.bam} -c {input.vcf} -o {output.outdir} -t {threads} -R {input.fasta} -X -e 0.02 > {log}' 

rule glopp_hybrid:
    input:
        fasta = 'references/used/{group}/refmap/{refori}.fa',
        fai   = 'references/used/{group}/refmap/{refori}.fa.fai',
        bam   = 'mapping/{group}/{refori}.nanopore.bam',
        bai   = 'mapping/{group}/{refori}.nanopore.bam.bai',
        short = 'mapping/{group}/{refori}.illumina.bam',
        vcf   = 'phasing/glopp/{group}/{refori}.illumina.{vcaller}.vcfc_header'
    output:
        outdir = directory('phasing/glopp/{group}/{refori}/hybrid/{vcaller}')
    benchmark:
        'benchmarks/{group}.glopp.{refori}.hybrid.{vcaller}.txt'
    conda:
        config['softparams']['conda']['glopp']
    threads:
        16
    log:
        'logs/{group}/glopp.{refori}.hybrid.{vcaller}.log'
    params:
        executable = GLOPP
    shell:
        '{params.executable} -b {input.bam} -c {input.vcf} -o {output.outdir} -t {threads} -R {input.fasta} -H {input.short} --reassign-short -X -e 0.01 > {log}'

checkpoint run_assembly:
    input:
        'phasing/glopp/{group}/{refori}/{gmode}/{vcaller}'
    output: 
        temp(touch('phasing/glopp/{group}/{refori}/{gmode}/{vcaller}.done'))

# ------------------------------------------------------------------------------------------------------------------------------------------
# Assembly


rule wtdbg2:
    input:
        'phasing/glopp/{group}/{refori}/{gmode}/{vcaller}/{contigID}/{rtype}/{partID}.fastq'
    output:
        'phasing/glopp/{group}/{refori}/{gmode}/{vcaller}/{contigID}/{rtype}/{partID}/{partID}.ctg.lay.gz'
    params:
        preset = '-x preset2 -e 5 -l 1000 -L 3000 -S 1 -R',
        of = 'phasing/glopp/{group}/{refori}/{gmode}/{vcaller}/{contigID}/{rtype}/{partID}/{partID}'
    conda:
        config['softparams']['conda']['wtdbg2']
    log:
        'logs/wtdbg2/wtdbg2.{group}.{refori}.{gmode}.{vcaller}.{contigID}.{rtype}.{partID}.log'
    benchmark:
        'benchmarks/wtdbg2.{group}.{refori}.{gmode}.{vcaller}.{contigID}.{rtype}.{partID}.txt'
    threads:
        4
    shell:
        'wtdbg2 {params.preset} -t {threads} -i {input} -o {params.of} 2> {log}'

rule wtpoa:
    input:
        rules.wtdbg2.output
    output:
        'phasing/glopp/{group}/{refori}/{gmode}/{vcaller}/{contigID}/{rtype}/{partID}/{partID}.ctg.fa'
    conda:
        config['softparams']['conda']['wtdbg2']
    log:
        'logs/wtdbg2/wtpoa.{group}.{refori}.{gmode}.{vcaller}.{contigID}.{rtype}.{partID}.log'
    benchmark:
        'benchmarks/wtpoa.{group}.{refori}.{gmode}.{vcaller}.{contigID}.{rtype}.{partID}.txt'
    threads:
        4
    shell:
        'wtpoa-cns -t {threads} -i {input} -fo {output} 2> {log}'

def aggregate_input_wtgdb2(wildcards):
    checkpoint_output = checkpoints.run_assembly.get(** wildcards).output[0][:-5]
    f = os.path.join(checkpoint_output, '*', wildcards.rtype, '*.fastq')
    f = glob.glob(f)

    for idx, fname in enumerate(f):

        if os.stat(fname).st_size == 0:
            # Sometime we have empty files, we juste ignore them
            continue

        partID = os.path.basename(fname)[:-6]
        f[idx] = os.path.join(os.path.dirname(fname), partID, partID + '.ctg.fa')

    return f

rule wtdbg2_merge:
    input:
        aggregate_input_wtgdb2
    output:
        'phasing/assemblies/{group}/{refori}.glopp.{gmode}.wtdbg2.{rtype}.{vcaller}.fa'
    script:
        'scripts/glopp_wtdbg2_merger.py'

rule assembly_compress:
    input:
        'phasing/assemblies/{group}/{refori}.glopp.{gmode}.{assembler}.{rtype}.{vcaller}.fa'
    output:
        'phasing/assemblies/{group}/{refori}.glopp.{gmode}.{assembler}.{rtype}.{vcaller}.fa.gz'
    shell:
        'gzip {input}'

rule uncompress:
    input:
        rules.assembly_compress.output
    output: 
        temp('temp/assemblies/{group}/{refori}.glopp.{gmode}.{assembler}.{rtype}.{vcaller}.fa')
    shell:
        'zcat {input} > {output}'
